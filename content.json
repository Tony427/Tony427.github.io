{"pages":[{"title":"關於我","text":"2010 半導體產業自動化工程師2012 海外鋼鐵業資訊處基層主管2014 獨自一人走遍中南美洲與南極的背包客2015 澳洲打工度假鍛鍊身體2016 回歸軟體業擔任軟體工程師 &amp; 系統設計師 &amp; 系統分析師…等等一條龍作業 持續進化中!! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"VS2017無法建置Dotnet Core 2.2","text":"在使用VS 2017作為IDE的狀況下，將.csporj檔案的Target強制改為2.2時，會發生無法建置的狀況，即使至官網下載了2.2的SDK依然錯誤。使用dotnet --version檢查dotnet core版本 Dotnet 2.2.1以下是使用MSBuild 15，可使用VS 2017建置 Dotnet 2.2.2以上使用MSBuild 16，要安裝VS 2019才能建置 但如果使用VSCode的話，dotnet build不受影響 The 2.2.202 SDK isn’t supported in Visual Studio 2017 due &gt; to it using MSBuild 16, which comes with Visual Studio 2019. To work around this issue, install the latest 2.2.1xx SDK. 資料來源 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/06/17/VS2017無法建置Dotnet-2-2/"},{"title":"Gitlab CI/CD建置 - 以 Dotnet Core為例","text":"GitLab 提供了非常方便的CI/CD工具，並且上傳到Gitlab就可以使用公用的runner來進行建置，不需要額外自己架Jenkins，就可以快速建立流水線，並且整合Slack等等工具，初次接觸CI/CD如我也是居然一下就成功了。 我們快速整理一下整個建置的流程。 寫專案，以及Test 撰寫.gitlab-ci.yml運行腳本，這邊以Build以及Test兩個任務為例。 當然就是要推上Gitlab版控囉。 Slack設定Webhooks(https://slack.com/apps/XXXXXXXXX-incoming-webhooks) Gitlab專案設定整合Slack notifacation service. 執行測試。 這樣就完成了自動build專案以及執行測試，並且會通知Slack的訊息 專案yaml檔案設定.gitlab-ci.yml123456789101112131415161718192021image: mcr.microsoft.com/dotnet/core/sdk:2.2stages: - build - testvariables: source_path: \"src\" test_path: \"tests\"build_api: stage: build script: - \"cd $source_path/GitlabCI.WebAPI\" - \"dotnet build\"test: stage: test script: - \"cd $test_path/GitlabCI.Test\" - \"dotnet test\" gitlab 設定slack設定參考文章 Gitlab官網 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/06/25/Gitlab-CI-CD建置-以-Dotnet-Core為例/"},{"title":"test","text":"test paste images document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/11/test/"},{"title":"Win10解壓縮亂碼","text":"Win10 美版改為中文語系的雷 問題目前是 Dell XPS 9370 美版整新機，出廠就是英文OS。本來是打算直接用英文介面，結果電腦拿去給公司資訊部設定AD，還有灌資安軟體，回來被直接安裝了中文語言包 😂 但總覺得使用上偶爾還是卡卡的，列一下遇到的雷。 cmder游標多一隔空格先是遇到了 cmder 大家都是用cp65001的utf-8才能正常顯示游標以及中文。找了好多篇文章嘗試，還是沒有解決。最後發現反而要用cp950的Big5編碼，才不會有游標多一格以及亂跑的問題。 zip內的中文檔名為亂碼接下來遇到的問題是，別人傳給我的zip檔，內部的檔案中文會變成亂碼。嘗試過網路上將語言、地區等等都設成台灣，一樣無法解決。最後也是將 WinRAR 的編碼改為Big5才能正常顯示。 結論系統不知道為何，預設編碼是Big5。 目前還找不到解法可以將系統預設改為UTF-8編碼。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/05/14/Win10解壓縮亂碼/"},{"title":"避免多重登入送出錯誤資料","text":"故事是這樣的… 某金融客戶站台接到客訴客戶登入了兩個網頁 (先不要問我user怎麼這麼神奇可以幹這件事) A帳號沒登出，B帳號又登入結果A帳號又在原本的頁面送出表單然後 Boom !! Magic… A帳號的資料寫進去B帳號了 問題 估計應該是user開了兩個分頁第一個分頁停在某個表單頁面尚未送出第二個頁面一開始也是用A帳號登入之後登出改用B帳號 怎麼解決 解決構想來自於MVC的AntiForgeryToken作法。 登入時產生新的Token，並存入Session 前端產生hidden欄位存入token post到後端時檢查目前Session中token與前端post過來的token是否相符如此一來不同Tab在post資料時，若與目前Session中Token不相符，則進行後續導頁或登出動作 開始實作 前端使用HtmlHelperHtmlHelper用來在前端使用Razor語法產生Token 1234567891011121314151617using System.Web;using System.Web.Mvc;namespace SingleLogin.Web.Helpers{ public static class CustomHelpers { public static MvcHtmlString IsSingleLoginToken(this HtmlHelper helper) { string name = \"SingleLoginToken\"; //hidden欄位的name與id名稱 string value = HttpContext.Current.Session[\"SingleLoginToken\"].ToString(); //hidden的value return MvcHtmlString.Create( $\"&lt;input type=\\\"hidden\\\" id=\\\"{name}\\\" name=\\\"{name}\\\" value=\\\"{value}\\\"&gt;\" ); } }} 使用方法如下： 在WebConfig中加入namespace 12345678910&lt;namespaces&gt; &lt;add namespace=\"System.Web.Helpers\" /&gt; &lt;add namespace=\"System.Web.Mvc\" /&gt; &lt;add namespace=\"System.Web.Mvc.Ajax\" /&gt; &lt;add namespace=\"System.Web.Mvc.Html\" /&gt; &lt;add namespace=\"System.Web.Optimization\" /&gt; &lt;add namespace=\"System.Web.Routing\" /&gt; &lt;add namespace=\"System.Web.WebPages\" /&gt; &lt;add namespace=\"SingleLogin.Web.Helpers\" /&gt;&lt;/namespaces&gt; View引入命名空間後使用`@Html.IsSingleLoginToken()`即可，使用方法跟AntiForgeryToken差不多 後端Controller加上ActionFilterFilter 用來在後端Controller加上[IsSingleLogin]，用來驗證前端Post過來的Token值 123456789101112131415161718192021222324252627using System.Web.Mvc;namespace SingleLogin.Web.ActionFilters{ /// &lt;summary&gt; /// 透過檢查埋入前端html的Token，比對後端Session中的token是否相同，以避免不同身分操作錯誤資料 /// &lt;/summary&gt; public class IsSingleLoginAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext filterContext) { string sessionVariableName = \"SingleLoginToken\"; string clientVariableName = \"SingleLoginToken\"; var serverSession = filterContext.HttpContext.Session[sessionVariableName].ToString(); var clientSession = filterContext.HttpContext.Request.Form[clientVariableName].ToString(); if (serverSession != clientSession) { filterContext.Result = new ContentResult() { ContentType = \"text/html; charset=UTF-8\", //用js alert後導頁登出 Content = \"&lt;script_&gt;alert('系統偵測到您同時以兩個帳號登入同一個瀏覽器');window.location.href = '/Member/Logout';&lt;/script&gt;\" }; } } }} 小結 前端就使用@Html.IsSingleLoginToken()後端Controller加上 [IsSingleLogin] Filter就可以簡單的加上驗證功能 跟菜鳥時期一頁一頁處理的過去說掰掰 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2017/07/27/避免多重登入送出錯誤資料/"},{"title":"溝通技巧","text":"今天聚會時又學到了很多，一直覺得自己在職涯遇到了一些瓶頸，不單只是技術上有無進步(硬實力)，也包含要怎麼跟人有效的溝通(軟實力)。 現在很多敏捷式開發、或是組織扁平化等等，其實都是為了解決「溝通」的問題。 例如: kanban、站立會議…等等，其實都是在不斷地「同步訊息」與凝聚「共識」 (才學疏淺，尚未真正深入體會整個過程，但也不斷的嘗試導入一部分探索中) 當資訊越透明越公開，相對地就減少了很多溝通的成本。 會議開很久，無法聚焦怎麼辦? 會議之前，先把自己在會議想要的東西先條列出來，確定自己今天在這場會議要得到那些承諾或結果。 向上管理 對沒條理的上級要幫他們整理好，然後用email或其他方式通知得到commit再做。 對目標導向的上級要主動回報進度，不要讓上級來找你，主動告知目前的狀況，遇到的問題，會用什麼方式對應，或是需要什麼資源。 對控制欲很有自己主見的上級某方面他想要證明自己是對的、或是比你強。順著他們的話，「這件事主管你比較有經驗，你說的這樣很有道理，如果再加上XX(帶入自己的意見)，你覺得怎麼樣呢？」繞著讓他們以為自己在做決定，引導到自己想要的結果。 訂一個年度目標 訂一些年度目標，時常拿出來檢視，也可以中途調整。重點是要常常拿出來review 小結論 做任何事之前，要先確認自己想達到的目的，條列出來。溝通時要先把情緒抽離，了解對方背後的需求，甚至自己出來summary，一方面幫了對方，一方面也主導結果往自己想要的地方走。不要嫌麻煩或是覺得不關自己的事。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/06/01/溝通技巧/"},{"title":"hexo admin 置放圖片","text":"copy and paste picture document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2019/09/11/hexo-admin-置放圖片/"}],"tags":[{"name":".NET Core","slug":"NET-Core","link":"/tags/NET-Core/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"JekyII","slug":"JekyII","link":"/tags/JekyII/"},{"name":"ROR","slug":"ROR","link":"/tags/ROR/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"Facebook","slug":"Facebook","link":"/tags/Facebook/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"VS2017","slug":"VS2017","link":"/tags/VS2017/"},{"name":"Gitlab","slug":"Gitlab","link":"/tags/Gitlab/"},{"name":"CI/CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"Windows 10","slug":"Windows-10","link":"/tags/Windows-10/"},{"name":"ASP.NET","slug":"ASP-NET","link":"/tags/ASP-NET/"},{"name":"Window 10","slug":"Window-10","link":"/tags/Window-10/"}],"categories":[{"name":"software","slug":"software","link":"/categories/software/"},{"name":"life","slug":"life","link":"/categories/life/"}]}