{"pages":[{"title":"關於我","text":"2010 半導體產業自動化工程師2012 海外鋼鐵業資訊處基層主管2014 獨自一人走遍中南美洲與南極的背包客2015 澳洲打工度假鍛鍊身體2016 回歸軟體業擔任軟體工程師 &amp; 系統設計師 &amp; 系統分析師…等等一條龍作業 持續進化中!!","link":"/about/index.html"}],"posts":[{"title":"Win10解壓縮亂碼","text":"Win10 美版安裝中文語言包的雷 問題目前是 Dell XPS 9370 美版整新機，因此出廠就是英文介面。本來是打算直接用英文介面，電腦拿去給公司資訊部設定AD，還有灌資安軟體，回來被直接安裝了中文語言包 :joy: 但總覺得使用上偶爾還是卡卡的，列一下遇到的雷。 先是遇到了 cmder 大家都是用cp65001的utf-8才能正常顯示游標以及中文。結果發現自己的要用cp950的Big5編碼，才不會有游標多一格以及亂跑的問題。 接下來發現別人傳給我的zip檔，內部的檔案中文會變成亂碼，也是去改 WinRAR 的編碼才能正常顯示。 嘗試過網路上將語言、地區等等都設成台灣，一樣無法解決。 結論應該是系統不知道為何，預設編碼是Big5。 目前還找不到解法可以將系統預設改為UTF-8編碼。","link":"/2019/05/14/Win10解壓縮亂碼/"},{"title":"避免多重登入送出錯誤資料","text":"故事是這樣的… 某金融客戶站台接到客訴客戶都登入了兩個網頁(先不要問我user怎麼這麼神奇可以幹這件事) A帳號沒登出，B帳號又登入結果A帳號又在原本的頁面送出表單然後 Boom !! Magic… A帳號的資料寫進去B帳號了 問題估計應該是user開了兩個分頁第一個分頁停在某個表單頁面尚未送出第二個頁面一開始也是用A帳號登入之後登出改用B帳號 怎麼解決解決構想來自於MVC的AntiForgeryToken作法。 登入時產生新的Guid，並存入Session 前端產生hidden欄位存入token post到後端時檢查目前Session中token與前端post過來的token是否相符如此一來不同Tab在post資料時，若與目前Session中Token不相符，則進行後續導頁或登出動作 開始實作前端使用HtmlHelperHtmlHelper用來在前端使用Razor語法產生Token 1234567891011121314151617using System.Web;using System.Web.Mvc;namespace SingleLogin.Web.Helpers{ public static class CustomHelpers { public static MvcHtmlString IsSingleLoginToken(this HtmlHelper helper) { string name = \"SingleLoginToken\"; //hidden欄位的name與id名稱 string value = HttpContext.Current.Session[\"SingleLoginToken\"].ToString(); //hidden的value return MvcHtmlString.Create( $\"&lt;input type=\\\"hidden\\\" id=\\\"{name}\\\" name=\\\"{name}\\\" value=\\\"{value}\\\"&gt;\" ); } }} 使用方法如下： 在WebConfig中加入namespace 12345678910&lt;namespaces&gt; &lt;add namespace=&quot;System.Web.Helpers&quot; /&gt; &lt;add namespace=&quot;System.Web.Mvc&quot; /&gt; &lt;add namespace=&quot;System.Web.Mvc.Ajax&quot; /&gt; &lt;add namespace=&quot;System.Web.Mvc.Html&quot; /&gt; &lt;add namespace=&quot;System.Web.Optimization&quot; /&gt; &lt;add namespace=&quot;System.Web.Routing&quot; /&gt; &lt;add namespace=&quot;System.Web.WebPages&quot; /&gt; &lt;add namespace=&quot;SingleLogin.Web.Helpers&quot; /&gt;&lt;/namespaces&gt; View引入命名空間後使用`@Html.IsSingleLoginToken()`即可，使用方法跟AntiForgeryToken差不多 後端Controller加上ActionFilterFilter 用來在後端Controller加上[IsSingleLogin]，用來驗證前端Post過來的Guid值123456789101112131415161718192021222324252627using System.Web.Mvc;namespace SingleLogin.Web.ActionFilters{ /// &lt;summary&gt; /// 透過檢查埋入前端html的Token，比對後端Session中的token是否相同，以避免不同身分操作錯誤資料 /// &lt;/summary&gt; public class IsSingleLoginAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext filterContext) { string sessionVariableName = \"SingleLoginToken\"; string clientVariableName = \"SingleLoginToken\"; var serverSession = filterContext.HttpContext.Session[sessionVariableName].ToString(); var clientSession = filterContext.HttpContext.Request.Form[clientVariableName].ToString(); if (serverSession != clientSession) { filterContext.Result = new ContentResult() { ContentType = \"text/html; charset=UTF-8\", //用js alert後導頁登出 Content = \"&lt;script&gt;alert('系統偵測到您同時以兩個帳號登入同一個瀏覽器');window.location.href = '/Member/Logout';&lt;/script&gt;\" }; } } }} 小結前端就使用@Html.IsSingleLoginToken()後端Controller加上 [IsSingleLogin] Filter就可以簡單的加上驗證功能 用AOP可以解方法的時候特別爽跟菜鳥時期一頁一頁處理的過去說掰掰","link":"/2017/07/27/避免多重登入送出錯誤資料/"}],"tags":[{"name":"Facebook","slug":"Facebook","link":"/tags/Facebook/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"DotnetCore","slug":"DotnetCore","link":"/tags/DotnetCore/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"win10","slug":"win10","link":"/tags/win10/"},{"name":"JekyII","slug":"JekyII","link":"/tags/JekyII/"},{"name":"ROR","slug":"ROR","link":"/tags/ROR/"},{"name":"dotnet","slug":"dotnet","link":"/tags/dotnet/"}],"categories":[{"name":"Software","slug":"Software","link":"/categories/Software/"},{"name":"Sofwtare","slug":"Sofwtare","link":"/categories/Sofwtare/"}]}