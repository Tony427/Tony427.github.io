{"pages":[{"title":"關於我","text":"2010 半導體產業自動化工程師2012 海外鋼鐵業資訊處基層主管2014 獨自一人走遍中南美洲與南極的背包客2015 澳洲打工度假鍛鍊身體2016 回歸軟體業擔任軟體工程師 &amp; 系統設計師 &amp; 系統分析師…等等一條龍作業 持續進化中!!","link":"/about/index.html"}],"posts":[{"title":"避免多重登入送出錯誤資料","text":"故事是這樣的… 某金融客戶站台接到客訴客戶都登入了兩個網頁(先不要問我user怎麼這麼神奇可以幹這件事) A帳號沒登出，B帳號又登入結果A帳號又在原本的頁面送出表單然後 Boom !! Magic… A帳號的資料寫進去B帳號了 問題估計應該是user開了兩個分頁第一個分頁停在某個表單頁面尚未送出第二個頁面一開始也是用A帳號登入之後登出改用B帳號 怎麼解決解決構想來自於MVC的AntiForgeryToken作法。 登入時產生新的Guid，並存入Session 前端產生hidden欄位存入token post到後端時檢查目前Session中token與前端post過來的token是否相符如此一來不同Tab在post資料時，若與目前Session中Token不相符，則進行後續導頁或登出動作 開始實作前端使用HtmlHelperHtmlHelper用來在前端使用Razor語法產生Token 1234567891011121314151617using System.Web;using System.Web.Mvc;namespace SingleLogin.Web.Helpers{ public static class CustomHelpers { public static MvcHtmlString IsSingleLoginToken(this HtmlHelper helper) { string name = \"SingleLoginToken\"; //hidden欄位的name與id名稱 string value = HttpContext.Current.Session[\"SingleLoginToken\"].ToString(); //hidden的value return MvcHtmlString.Create( $\"&lt;input type=\\\"hidden\\\" id=\\\"{name}\\\" name=\\\"{name}\\\" value=\\\"{value}\\\"&gt;\" ); } }} 使用方法如下： 在WebConfig中加入namespace 12345678910&lt;namespaces&gt; &lt;add namespace=&quot;System.Web.Helpers&quot; /&gt; &lt;add namespace=&quot;System.Web.Mvc&quot; /&gt; &lt;add namespace=&quot;System.Web.Mvc.Ajax&quot; /&gt; &lt;add namespace=&quot;System.Web.Mvc.Html&quot; /&gt; &lt;add namespace=&quot;System.Web.Optimization&quot; /&gt; &lt;add namespace=&quot;System.Web.Routing&quot; /&gt; &lt;add namespace=&quot;System.Web.WebPages&quot; /&gt; &lt;add namespace=&quot;SingleLogin.Web.Helpers&quot; /&gt;&lt;/namespaces&gt; View引入命名空間後使用`@Html.IsSingleLoginToken()`即可，使用方法跟AntiForgeryToken差不多 後端Controller加上ActionFilterFilter 用來在後端Controller加上[IsSingleLogin]，用來驗證前端Post過來的Guid值123456789101112131415161718192021222324252627using System.Web.Mvc;namespace SingleLogin.Web.ActionFilters{ /// &lt;summary&gt; /// 透過檢查埋入前端html的Token，比對後端Session中的token是否相同，以避免不同身分操作錯誤資料 /// &lt;/summary&gt; public class IsSingleLoginAttribute : ActionFilterAttribute { public override void OnActionExecuting(ActionExecutingContext filterContext) { string sessionVariableName = \"SingleLoginToken\"; string clientVariableName = \"SingleLoginToken\"; var serverSession = filterContext.HttpContext.Session[sessionVariableName].ToString(); var clientSession = filterContext.HttpContext.Request.Form[clientVariableName].ToString(); if (serverSession != clientSession) { filterContext.Result = new ContentResult() { ContentType = \"text/html; charset=UTF-8\", //用js alert後導頁登出 Content = \"&lt;script&gt;alert('系統偵測到您同時以兩個帳號登入同一個瀏覽器');window.location.href = '/Member/Logout';&lt;/script&gt;\" }; } } }} 小結前端就使用@Html.IsSingleLoginToken()後端Controller加上 [IsSingleLogin] Filter就可以簡單的加上驗證功能 用AOP可以解方法的時候特別爽跟菜鳥時期一頁一頁處理的過去說掰掰","link":"/2017/07/27/避免多重登入送出錯誤資料/"}],"tags":[{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"DotnetCore","slug":"DotnetCore","link":"/tags/DotnetCore/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"JekyII","slug":"JekyII","link":"/tags/JekyII/"},{"name":"ROR","slug":"ROR","link":"/tags/ROR/"},{"name":"Facebook","slug":"Facebook","link":"/tags/Facebook/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"},{"name":"Dotnet","slug":"Dotnet","link":"/tags/Dotnet/"},{"name":"dotnet","slug":"dotnet","link":"/tags/dotnet/"}],"categories":[{"name":"Software","slug":"Software","link":"/categories/Software/"},{"name":"software","slug":"software","link":"/categories/software/"}]}